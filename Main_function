              ############################################################
                                       # Fonctions  #
              ############################################################






#############################################################
#Construit une matrice symétrique à partir d'un vecteur
#############################################################
vect_mat_low <- function(V, diag=F)
{
  N <- length(V)
  if(diag == F) {n <- (1+sqrt(1+8*N))/2} else{ n <- (-1+sqrt(1+8*N))/2}
  M <- matrix(0,n,n) 
  M[lower.tri(M, diag=diag)] <- V
  B <- t(M)
  diag(B) <- 0
  M <- B + M
  return(M)
}


###########################################################################
#Construit un vecteur à partir d'une matrice triangulaire inférieure
###########################################################################
mat_vect_low <- function(M, diag=F)
{
  V <- M[lower.tri(M, diag = diag)]
  return(V)
}


############################################################################
#Passage d'une matrice binaire à un vecteur des indices 
############################################################################
mat_bin_to_vect_ind <- function(n,pi_melange)
{
   Z_m <- rmultinom(n, size = 1, prob = pi_melange)
   Z_v <- which(Z_m == 1, 1)
   Z_v <- Z_v[,1] 
   return(Z_v, Z_m)
 }


###########################################################################
#recuperer les indices de la matrice triangulaire inferieure 
###########################################################################

# indices <- function(n)
# {
#   N  <- n * (n-1)/2
#   S=matrix(1:n^2, ncol=n)
#   V <- S[lower.tri(S, diag = F)]
#   j <- (V%/%(n+1))+1
#   i <- V%%n
#   i[which(i==0)]<-n
#   return(cbind(matrix(c(i,j),ncol=2)))
# }

indices <- function(n, diag=F)
{
  N  <- (n * (n-1)/2)*(diag==F) +(n * (n+1)/2)*(diag==T)
  S <- vect_mat_low(c(1:N), diag=diag)
  S[upper.tri(S)]=0
  return(which(S!=0,arr.ind=T))

}


############################################################################
#passer de n à N et inversement:
############################################################################

#N <- n*(n-1)/2
#n <-(1+sqrt(1+8*N))/2




############################################################################

############################################################################

#fonction de classes des observations
SIMULDATA <- function(gamma_arrete, pi_melange, n) {
  P = n*(n-1)/2
  #fonction de classes des observations
  Z_m <- rmultinom(n, size = 1, prob = pi_melange)
  Z_v <- which(Z_m == 1, 1)
  Z_v <- Z_v[,1] 
  #matrice des proba d'arrete gamma entre observations de chaque classe
  M <- matrix(0, ncol = length(pi_melange), nrow = length(pi_melange))
  colnames(M) = paste("Z", 1:length(pi_melange), sep = "")
  rownames(M) = paste("Z", 1:length(pi_melange), sep = "")
  
  M[lower.tri(M, diag=T)] <- gamma_arrete
  B <- t(M)
  diag(B) <- 0
  M <- B + M
  
  #G la matrice d'adjacence
  G <- matrix(rbinom(n*n, size = 1, prob = M[Z_v,Z_v]), n, n)
  
  
  #On construit le graph d'adjacence non dirigé:
  #Arbitrairement on récupère la matrice superieure de la matrice d'adjacence R et on la symetrise.
  #ATTENTION ne pas faire tourner l'algo suivant si on veut un graph dirigé
  
  
  G[lower.tri(G, diag=T)] <- 0
  G <- t(G)+G
  
  
  
  #On construit la matrice de précision Omega = G + nu_var*D
  #et on trouve le nu_var le plus petit possible pour rendre la matrice Omega inversible
  #D est la matrice de degré
  
  
  
  D2 <- apply(G,1,sum) #on fait la somme sur les lignes [trouver un autre moyen avec les matrice d'adjacence dirigée(sum sur ligne different que sur colonne)]
  #on met ce vecteur sur une matrice diagonale pour récuperer la matrice de degré D
  D <- matrix(0, ncol=n, nrow=n)
  diag(D) <- D2
  
  
  
  
  
  
  #construction de la matrice Omega
  nu_var <- 0
  mu_var <- 0
  Omega <- (nu_var + 0.1) * D + (mu_var + 0.3) * G 
  
  while((min(eigen(Omega)$values)) <= 1e-4) {
    nu_var <- nu_var + 0.1
    mu_var <- mu_var + 0.1
    Omega <- (nu_var + 0.1) * D + (mu_var + 0.3) * G 
    
  }
  Omega <- Omega / mean(Omega)
  Sigma <- solve(Omega)
  
  
  #On génère des simulation de gaussiennes centrées de variance sigma sur 4 sites:
  
  Y <- mvrnorm(100, mu = c(0,0,0,0,0,0,0,0,0,0), Sigma = Sigma)
  Y_abondance <- t(Y) %*% Y
  
  
  return(list(Y,G))
}

################################################################################################
################################################################################################
fun_test<-function(a_i_b_i){
  
  return(exp(seq(log(a_i_b_i["a"]),log(a_i_b_i["b"]),length.out = a_i_b_i["k"])))
}

#######################################################################################################
#######################################################################################################



recup_scores <- function(Y){
  
  n <- length(Y[1,])
  N <- n*(n-1)/2
  
  Huge.edge = huge(Y, method='glasso')
  lambda.step = exp(mean(diff(log(Huge.edge$lambda))))
  lambda.min = min(Huge.edge$lambda)
  lambda.max = max(Huge.edge$lambda)
  lambda.nb = length(Huge.edge$lambda)
  
  #On veut qu'aucune aretes soient présentent au début donc que df=0 donc lambda max assez grand 
  while(min(Huge.edge$df)>0){
    lambda.max = lambda.max/(lambda.step)^5
    Huge.edge = huge(Y, method='glasso', lambda=lambda.max)
    
  }
  
  
  while(max(Huge.edge$df)<N){
    lambda.min = lambda.min*(lambda.step)^5
    Huge.edge = huge(Y, method='glasso', lambda=lambda.min)
    #plot(Huge.edge$lambda, Huge.edge$df, log='x'); abline(h=c(0, N))
    
  }
  
  
  
  
  lambda.seq = unique(sort(unlist(new.lambda.seq), decreasing = T))
  Huge.edge = huge(Y, method = 'glasso', lambda=lambda.seq)
  plot(Huge.edge$lambda, Huge.edge$df, log = 'x')
  
  longueur <- length(lambda.seq)
  
  ##construction matrice de scores
  S <- matrix(0,ncol=n,nrow=n)
  for(i in 1:n){
    for(j in 1:n){
     if(i != j){
       S[i,j] <- lambda.seq[min(which(lapply(Huge.edge$path, function(P) P[i,j])==1))]
     } 
    }
  }
  
  
  diag(S) = 0
  score <- log(S)
  diag(score) <- 0
  return(score)
}
#######################################################################################################

